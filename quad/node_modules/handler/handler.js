const Lexer = require('./lexer');
const HandlerCommandMatcher = require("./handlercommandmatcher");
const HandlerCommand = require("./handlercommand");
const ratelimit = require("ratelimit");
const config = require("config");
const i18n = require("i18n");
const EventEmitter = require("events");

const commandRatelimit = config.get("bot.ratelimit.commands");

class Handler extends EventEmitter {
    #commands;
    #bot;
    #pendingListeners;
    
    constructor() {
        super();
        
        this.#commands = [];
        this.#pendingListeners = [];
    }
    
    async process(prefix, message) {
        let l = new Lexer(message.content.substr(prefix.length));
        if (l.atEnd) return;
        
        try {
            let firstToken = l.lex();
            if (firstToken.type !== "string") {
                message.channel.createMessage("Syntax Error");
                return;
            }
            
            //Iterate over the commands and find the commands with this name
            let matchers = [];
            for (let command of this.#commands) {
                if (command.name == firstToken.value) matchers.push(new HandlerCommandMatcher(command, message.channel.guild));
            }
            if (matchers.length === 0) return; //No such command exists
            
            //Now attempt to match the rest of the tokens with the command
            while (!l.atEnd) {
                let token = l.lex();
                for (let matcher of matchers) {
                    matcher.token(token);
                }
            }
            
            //And run all the commands that match
            let commandRun = false;
            for (let matcher of matchers) {
                if (!matcher.canRunCommand()) continue;
                commandRun = true;
                
                //Ensure we have permissions
                if (!matcher.havePermission(message.member)) continue;
                
                //Check ratelimits
                let count = ratelimit.hit(message.author.id, config.get("bot.ratelimit.per"));
                if (count < commandRatelimit) {
                    matcher.runCommand(prefix, message);
                } else if (count < commandRatelimit + 3) {
                    let t = (await i18n(message.author)).t;
                    message.channel.createMessage(t("**Cool it, buddy!**\nYou're using {{botname}} too fast. You'll be able to use Quad again in **{{count}} seconds**.", {
                        botname: config.get("bot.name"),
                        count: (ratelimit.timeout(message.author.id) / 1000).toFixed(1)
                    }));
                } else {
                    //Ignore the user now; they've been told enough
                }
            }
            
            //Check if any commands were run
            if (!commandRun) {
                //Invalid arguments; print an error
                message.channel.createMessage("Invalid Arguments");
            }
        } catch (err) {
            message.channel.createMessage(err.message);
            console.log(err);
        }
    }
    
    setBot(bot) {
        this.#bot = bot;
        
        for (let listener of this.#pendingListeners) {
            this.#bot.on(listener.name, listener.listener);
        }
        this.#pendingListeners = [];
        
        this.emit("botAvailable");
    }
    
    get bot() {
        return this.#bot;
    }
    
    register(name, args, func) {
        let command = new HandlerCommand(name, args, func);
        this.#commands.push(command);
    }
    
    listen(eventName, listener) {
        if (this.#bot) {
            this.#bot.on(eventName, listener);
        } else {
            this.#pendingListeners.push({
                name: eventName,
                listener: listener
            });
        }
    }
    
    stopListen(eventName, listener) {
        this.#bot.off(eventName, listener);
    }
    
    get commands() {
        return this.#commands;
    }
}

let handler = new Handler();
module.exports = handler;