const db = require("db");
const i18n = require("i18n");

class HandlerCommandMatcher {
    #hc;
    #guild;
    #args;
    #flags;
    #sink;
    
    constructor(hc, guild) {
        this.#hc = hc;
        this.#guild = guild;
        this.#args = [];
        this.#flags = {};
        this.#sink = false;
    }
    
    matchType(value, type) {
        switch (type) {
            case "string": {
                //Function expects a string and we've got a string :)
                return {
                    value: value,
                    success: true
                };
            }
            case "void": {
                //Check for an empty string
                if (value === "") {
                    return {
                        value: true, //Use true so we can use it in an if statement
                        success: true
                    };
                } else {
                    return {
                        success: false
                    };
                }
            }
            case "number": {
                let number = +value;
                if (isNaN(number)) {
                    return {
                        success: false
                    };
                } else {
                    return {
                        value: number,
                        success: true
                    };
                }
            }
            case "user": {
                if (this.#guild) {
                    let member = this.#guild.members.reduce((oldMember, member) => {
                        if (member.id === value) return {
                            m: member,
                            priority: 0
                        };
                        
                        if (`${member.username}#${member.discriminator}` === value && oldMember.priority > 1) return {
                            m: member,
                            priority: 1
                        };
                        
                        if (`${member.username}#${member.discriminator}`.toLowerCase().includes(value.toLowerCase()) && oldMember.priority > 2) return {
                            m: member,
                            priority: 2
                        };
                        return oldMember;
                    }, {
                        m: null,
                        priority: 100
                    });
                    
                    if (member.m !== null) return {
                        value: member.m,
                        success: true
                    }
                }
            }
        }
        
        //Unknown type
        return {
            success: false
        };
    }
    
    token(token) {
        //If we're in a sink state, don't bother doing anything
        if (this.#sink) return;
        
        if (token.type === "flag") {
            //Look for a matching flag and set it
            if (this.#flags.hasOwnProperty(token.name)) {
                //Flag already exists
                throw new Error("Flag set twice");
            }
            
            let flagSet = false;
            for (let flag of this.#hc.flags) {
                if (flag.name === token.name) {
                    //Now attempt to match the type of this flag to the string
                    let result = this.matchType(token.value, flag.type);
                    if (result.success) {
                        this.#flags[flag.name] = result.value;
                        flagSet = true;
                    } else {
                        //Sink the function
                        this.#sink = true;
                        return;
                    }
                }
            }
            
            if (!flagSet) {
                //Flag does not work with this function
                this.#sink = true;
                return;
            }
        } else {
            //Try to parse as the next arg
            let argNumber = this.#args.length;
            
            if (this.#hc.args.length <= argNumber) {
                //Too many args
                this.#sink = true;
                return;
            }
            let arg = this.#hc.args[argNumber];
            
            //Now attempt to match the type of this arg to the string
            let result = this.matchType(token.value, arg.type);
            if (result.success) {
                this.#args.push(result.value);
            } else {
                //Sink the function
                this.#sink = true;
                return;
            }
        }
    }
    
    async runCommand(message) {
        let opts = {};
        if (this.#hc.opts.translatorRequired) {
            opts.t = (await i18n(message)).t;
        }
        if (this.#hc.opts.dbRequired) {
            opts.db = (await db.get());
        }
        await this.#hc.func(message, opts, this.#args, this.#flags);
        if (this.#hc.opts.dbRequired && !this.#hc.opts.noReleaseDb) {
            opts.db.release();
        }
    }
    
    get canRunCommand() {
        //All args need to be satisfied, and sink must be false.
        if (this.#sink) return false;
        if (this.#hc.args.length !== this.#args.length) return false;
        
        return true;
    }
}

module.exports = HandlerCommandMatcher;