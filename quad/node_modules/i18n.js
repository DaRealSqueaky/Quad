const fs = require('fs');
const i18next = require('i18next');
const db = require('db');
const Eris = require('eris');
const moment = require('moment-timezone');
let i18nextbackend = require('i18next-node-fs-backend');

let availableTranslations = fs.readdirSync("translations");
i18next.use(i18nextbackend).init({
    fallbackLng: false,
    nsSeparator: false,
    keySeparator: false,
    preload: availableTranslations,
    ns: ["translation"],
    returnEmptyString: false,
    backend: {
        loadPath: "./translations/{{lng}}/{{ns}}.json"
    },
    interpolation: {
        format: function fmt(value, format, lng) {
            if (value.duration && moment.isDuration(value.duration)) {
                //Special case for Chinese
                if (lng.startsWith("zh")) lng = "zh-cn";

                let m = value.duration.locale(lng);
                
                if (format == "humanize") {
                    return m.humanize(value.prefixed);
                } else {
                    return m.format(format, value.settings);
                }
            }

            if (value.date) {
                //maybe have different formats here later
                //also take into account the user's 12/24h settings somehow at some point

                //Special case for Chinese
                if (lng.startsWith("zh")) lng = "zh-cn";

                let m = value.date.locale(lng);
                if (value.offset != null) {
                    m = m.utcOffset(value.offset);
                }

                if (format == "datetime") {
                    return m.format("dddd DD MMMM YYYY HH:mm:ss");
                } else if (format == "date") {
                    return m.format("dddd DD MMMM YYYY");
                } else if (format == "time") {
                    if (value.h24) {
                        return m.format("HH:mm:ss");
                    } else {
                        return m.format("hh:mm:ss A");
                    }
                } else if (format == "stime") {
                    if (value.h24) {
                        return m.format("HH:mm");
                    } else {
                        return m.format("hh:mm A");
                    }
                } else {
                    return m.format(format);
                }
            }
            if (format == "bold") return "**" + value + "**";
            return value;
        },
        escapeValue: false
    }
});

function notAsyncTrForDescriptor(translator) {
    if (availableTranslations.includes(translator)) {
        return {
            t: i18next.getFixedT(translator, "translation")
        };
    }
    
    return {
        t: i18next.getFixedT("en", "translation")
    };
}

async function trForDescriptor(translator) {
    if (translator.constructor === Eris.Message) {
        //Get the translation for the author
        translator = translator.author;
    }
    
    if (translator.constructor === Eris.Guild) {
        //Get the translation for guild ID
        let response = await db.getPool().query("SELECT * FROM guildLocales WHERE id=$1", [translator.id]);
        
        if (response.rowCount > 0) {
            translator = response.rows[0].locale;
        } else {
            translator = "en";
        }
    }
    
    if (translator.constructor === Eris.User) {
        //Get the translation for user ID
        let response = await db.getPool().query("SELECT * FROM userLocales WHERE id=$1", [translator.id]);
        
        if (response.rowCount > 0) {
            translator = response.rows[0].locale;
        } else {
            translator = "en";
        }
    }
    
    return notAsyncTrForDescriptor(translator);
}

module.exports = trForDescriptor;
module.exports.t = notAsyncTrForDescriptor(process.env["LANG"]).t
module.exports.availableTranslations = availableTranslations;